<?php
/**
 * DefaultApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Lago\LagoPhpClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Lago API documentation
 *
 * Lago API allows your application to push customer information and metrics (events) from your application to the billing application.
 *
 * The version of the OpenAPI document: 1.31.0
 * Contact: tech@getlago.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Lago\LagoPhpClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Lago\LagoPhpClient\ApiException;
use Lago\LagoPhpClient\Configuration;
use Lago\LagoPhpClient\FormDataProcessor;
use Lago\LagoPhpClient\HeaderSelector;
use Lago\LagoPhpClient\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Lago\LagoPhpClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'alertTriggered' => [
            'application/json',
        ],
        'creditNoteCreated' => [
            'application/json',
        ],
        'creditNoteGenerated' => [
            'application/json',
        ],
        'creditNoteProviderRefundFailure' => [
            'application/json',
        ],
        'customerAccountingProviderCreated' => [
            'application/json',
        ],
        'customerAccountingProviderError' => [
            'application/json',
        ],
        'customerCheckoutUrlGenerated' => [
            'application/json',
        ],
        'customerCreated' => [
            'application/json',
        ],
        'customerCrmProviderCreated' => [
            'application/json',
        ],
        'customerCrmProviderError' => [
            'application/json',
        ],
        'customerPaymentProviderCreated' => [
            'application/json',
        ],
        'customerPaymentProviderError' => [
            'application/json',
        ],
        'customerTaxProviderError' => [
            'application/json',
        ],
        'customerUpdated' => [
            'application/json',
        ],
        'customerViesCheck' => [
            'application/json',
        ],
        'eventError' => [
            'application/json',
        ],
        'eventsErrors' => [
            'application/json',
        ],
        'feeCreated' => [
            'application/json',
        ],
        'feeTaxProviderError' => [
            'application/json',
        ],
        'integrationProviderError' => [
            'application/json',
        ],
        'invoiceAddOnAdded' => [
            'application/json',
        ],
        'invoiceCreated' => [
            'application/json',
        ],
        'invoiceDrafted' => [
            'application/json',
        ],
        'invoiceGenerated' => [
            'application/json',
        ],
        'invoiceOneOffCreated' => [
            'application/json',
        ],
        'invoicePaidCreditAdded' => [
            'application/json',
        ],
        'invoicePaymentDisputeLost' => [
            'application/json',
        ],
        'invoicePaymentFailure' => [
            'application/json',
        ],
        'invoicePaymentOverdue' => [
            'application/json',
        ],
        'invoicePaymentStatusUpdated' => [
            'application/json',
        ],
        'invoiceResynced' => [
            'application/json',
        ],
        'invoiceVoided' => [
            'application/json',
        ],
        'paymentProviderError' => [
            'application/json',
        ],
        'paymentRequestCreated' => [
            'application/json',
        ],
        'paymentRequestPaymentFailure' => [
            'application/json',
        ],
        'paymentRequestPaymentStatusUpdated' => [
            'application/json',
        ],
        'paymentRequiresAction' => [
            'application/json',
        ],
        'planCreated' => [
            'application/json',
        ],
        'planDeleted' => [
            'application/json',
        ],
        'planUpdated' => [
            'application/json',
        ],
        'subscriptionStarted' => [
            'application/json',
        ],
        'subscriptionTerminated' => [
            'application/json',
        ],
        'subscriptionTerminationAlert' => [
            'application/json',
        ],
        'subscriptionTrialEnded' => [
            'application/json',
        ],
        'subscriptionUsageThresholdReached' => [
            'application/json',
        ],
        'walletDepletedOngoingBalance' => [
            'application/json',
        ],
        'walletTransactionCreated' => [
            'application/json',
        ],
        'walletTransactionPaymentFailure' => [
            'application/json',
        ],
        'walletTransactionUpdated' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation alertTriggered
     *
     * A new alert was triggered
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\AlertTriggeredRequest|null $alert_triggered_request Details of the triggered alert (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertTriggered'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function alertTriggered($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request = null, string $contentType = self::contentTypes['alertTriggered'][0])
    {
        $this->alertTriggeredWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request, $contentType);
    }

    /**
     * Operation alertTriggeredWithHttpInfo
     *
     * A new alert was triggered
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\AlertTriggeredRequest|null $alert_triggered_request Details of the triggered alert (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertTriggered'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function alertTriggeredWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request = null, string $contentType = self::contentTypes['alertTriggered'][0])
    {
        $request = $this->alertTriggeredRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation alertTriggeredAsync
     *
     * A new alert was triggered
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\AlertTriggeredRequest|null $alert_triggered_request Details of the triggered alert (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertTriggered'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function alertTriggeredAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request = null, string $contentType = self::contentTypes['alertTriggered'][0])
    {
        return $this->alertTriggeredAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation alertTriggeredAsyncWithHttpInfo
     *
     * A new alert was triggered
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\AlertTriggeredRequest|null $alert_triggered_request Details of the triggered alert (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertTriggered'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function alertTriggeredAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request = null, string $contentType = self::contentTypes['alertTriggered'][0])
    {
        $returnType = '';
        $request = $this->alertTriggeredRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'alertTriggered'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\AlertTriggeredRequest|null $alert_triggered_request Details of the triggered alert (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['alertTriggered'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function alertTriggeredRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $alert_triggered_request = null, string $contentType = self::contentTypes['alertTriggered'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling alertTriggered'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling alertTriggered'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling alertTriggered'
            );
        }



        $resourcePath = '/alert_triggered';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($alert_triggered_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($alert_triggered_request));
            } else {
                $httpBody = $alert_triggered_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditNoteCreated
     *
     * A new credit note has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteCreatedRequest|null $credit_note_created_request Details of the new credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditNoteCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request = null, string $contentType = self::contentTypes['creditNoteCreated'][0])
    {
        $this->creditNoteCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request, $contentType);
    }

    /**
     * Operation creditNoteCreatedWithHttpInfo
     *
     * A new credit note has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteCreatedRequest|null $credit_note_created_request Details of the new credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditNoteCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request = null, string $contentType = self::contentTypes['creditNoteCreated'][0])
    {
        $request = $this->creditNoteCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation creditNoteCreatedAsync
     *
     * A new credit note has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteCreatedRequest|null $credit_note_created_request Details of the new credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditNoteCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request = null, string $contentType = self::contentTypes['creditNoteCreated'][0])
    {
        return $this->creditNoteCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditNoteCreatedAsyncWithHttpInfo
     *
     * A new credit note has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteCreatedRequest|null $credit_note_created_request Details of the new credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditNoteCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request = null, string $contentType = self::contentTypes['creditNoteCreated'][0])
    {
        $returnType = '';
        $request = $this->creditNoteCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditNoteCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteCreatedRequest|null $credit_note_created_request Details of the new credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function creditNoteCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_created_request = null, string $contentType = self::contentTypes['creditNoteCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling creditNoteCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling creditNoteCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling creditNoteCreated'
            );
        }



        $resourcePath = '/credit_note_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credit_note_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credit_note_created_request));
            } else {
                $httpBody = $credit_note_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditNoteGenerated
     *
     * A new credit note PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteGeneratedRequest|null $credit_note_generated_request Details of the credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteGenerated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditNoteGenerated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request = null, string $contentType = self::contentTypes['creditNoteGenerated'][0])
    {
        $this->creditNoteGeneratedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request, $contentType);
    }

    /**
     * Operation creditNoteGeneratedWithHttpInfo
     *
     * A new credit note PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteGeneratedRequest|null $credit_note_generated_request Details of the credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteGenerated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditNoteGeneratedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request = null, string $contentType = self::contentTypes['creditNoteGenerated'][0])
    {
        $request = $this->creditNoteGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation creditNoteGeneratedAsync
     *
     * A new credit note PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteGeneratedRequest|null $credit_note_generated_request Details of the credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditNoteGeneratedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request = null, string $contentType = self::contentTypes['creditNoteGenerated'][0])
    {
        return $this->creditNoteGeneratedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditNoteGeneratedAsyncWithHttpInfo
     *
     * A new credit note PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteGeneratedRequest|null $credit_note_generated_request Details of the credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditNoteGeneratedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request = null, string $contentType = self::contentTypes['creditNoteGenerated'][0])
    {
        $returnType = '';
        $request = $this->creditNoteGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditNoteGenerated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteGeneratedRequest|null $credit_note_generated_request Details of the credit note (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function creditNoteGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_generated_request = null, string $contentType = self::contentTypes['creditNoteGenerated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling creditNoteGenerated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling creditNoteGenerated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling creditNoteGenerated'
            );
        }



        $resourcePath = '/credit_note_generated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credit_note_generated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credit_note_generated_request));
            } else {
                $httpBody = $credit_note_generated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditNoteProviderRefundFailure
     *
     * The refund of a credit note has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteProviderRefundFailureRequest|null $credit_note_provider_refund_failure_request Details of the credit note and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteProviderRefundFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditNoteProviderRefundFailure($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request = null, string $contentType = self::contentTypes['creditNoteProviderRefundFailure'][0])
    {
        $this->creditNoteProviderRefundFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request, $contentType);
    }

    /**
     * Operation creditNoteProviderRefundFailureWithHttpInfo
     *
     * The refund of a credit note has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteProviderRefundFailureRequest|null $credit_note_provider_refund_failure_request Details of the credit note and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteProviderRefundFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditNoteProviderRefundFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request = null, string $contentType = self::contentTypes['creditNoteProviderRefundFailure'][0])
    {
        $request = $this->creditNoteProviderRefundFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation creditNoteProviderRefundFailureAsync
     *
     * The refund of a credit note has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteProviderRefundFailureRequest|null $credit_note_provider_refund_failure_request Details of the credit note and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteProviderRefundFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditNoteProviderRefundFailureAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request = null, string $contentType = self::contentTypes['creditNoteProviderRefundFailure'][0])
    {
        return $this->creditNoteProviderRefundFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditNoteProviderRefundFailureAsyncWithHttpInfo
     *
     * The refund of a credit note has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteProviderRefundFailureRequest|null $credit_note_provider_refund_failure_request Details of the credit note and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteProviderRefundFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditNoteProviderRefundFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request = null, string $contentType = self::contentTypes['creditNoteProviderRefundFailure'][0])
    {
        $returnType = '';
        $request = $this->creditNoteProviderRefundFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditNoteProviderRefundFailure'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CreditNoteProviderRefundFailureRequest|null $credit_note_provider_refund_failure_request Details of the credit note and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['creditNoteProviderRefundFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function creditNoteProviderRefundFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $credit_note_provider_refund_failure_request = null, string $contentType = self::contentTypes['creditNoteProviderRefundFailure'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling creditNoteProviderRefundFailure'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling creditNoteProviderRefundFailure'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling creditNoteProviderRefundFailure'
            );
        }



        $resourcePath = '/credit_note_provider_refund_failure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credit_note_provider_refund_failure_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credit_note_provider_refund_failure_request));
            } else {
                $httpBody = $credit_note_provider_refund_failure_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerAccountingProviderCreated
     *
     * A customer was created on an accouting integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderCreatedRequest|null $customer_accounting_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerAccountingProviderCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request = null, string $contentType = self::contentTypes['customerAccountingProviderCreated'][0])
    {
        $this->customerAccountingProviderCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request, $contentType);
    }

    /**
     * Operation customerAccountingProviderCreatedWithHttpInfo
     *
     * A customer was created on an accouting integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderCreatedRequest|null $customer_accounting_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerAccountingProviderCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request = null, string $contentType = self::contentTypes['customerAccountingProviderCreated'][0])
    {
        $request = $this->customerAccountingProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerAccountingProviderCreatedAsync
     *
     * A customer was created on an accouting integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderCreatedRequest|null $customer_accounting_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerAccountingProviderCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request = null, string $contentType = self::contentTypes['customerAccountingProviderCreated'][0])
    {
        return $this->customerAccountingProviderCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerAccountingProviderCreatedAsyncWithHttpInfo
     *
     * A customer was created on an accouting integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderCreatedRequest|null $customer_accounting_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerAccountingProviderCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request = null, string $contentType = self::contentTypes['customerAccountingProviderCreated'][0])
    {
        $returnType = '';
        $request = $this->customerAccountingProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerAccountingProviderCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderCreatedRequest|null $customer_accounting_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerAccountingProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_created_request = null, string $contentType = self::contentTypes['customerAccountingProviderCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerAccountingProviderCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerAccountingProviderCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerAccountingProviderCreated'
            );
        }



        $resourcePath = '/customer_accounting_provider_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_accounting_provider_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_accounting_provider_created_request));
            } else {
                $httpBody = $customer_accounting_provider_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerAccountingProviderError
     *
     * An error was encountered while syncing a customer to an accounting provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderErrorRequest|null $customer_accounting_provider_error_request Details of the customer and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerAccountingProviderError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request = null, string $contentType = self::contentTypes['customerAccountingProviderError'][0])
    {
        $this->customerAccountingProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request, $contentType);
    }

    /**
     * Operation customerAccountingProviderErrorWithHttpInfo
     *
     * An error was encountered while syncing a customer to an accounting provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderErrorRequest|null $customer_accounting_provider_error_request Details of the customer and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerAccountingProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request = null, string $contentType = self::contentTypes['customerAccountingProviderError'][0])
    {
        $request = $this->customerAccountingProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerAccountingProviderErrorAsync
     *
     * An error was encountered while syncing a customer to an accounting provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderErrorRequest|null $customer_accounting_provider_error_request Details of the customer and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerAccountingProviderErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request = null, string $contentType = self::contentTypes['customerAccountingProviderError'][0])
    {
        return $this->customerAccountingProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerAccountingProviderErrorAsyncWithHttpInfo
     *
     * An error was encountered while syncing a customer to an accounting provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderErrorRequest|null $customer_accounting_provider_error_request Details of the customer and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerAccountingProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request = null, string $contentType = self::contentTypes['customerAccountingProviderError'][0])
    {
        $returnType = '';
        $request = $this->customerAccountingProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerAccountingProviderError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerAccountingProviderErrorRequest|null $customer_accounting_provider_error_request Details of the customer and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerAccountingProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerAccountingProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_accounting_provider_error_request = null, string $contentType = self::contentTypes['customerAccountingProviderError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerAccountingProviderError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerAccountingProviderError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerAccountingProviderError'
            );
        }



        $resourcePath = '/customer_accounting_provider_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_accounting_provider_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_accounting_provider_error_request));
            } else {
                $httpBody = $customer_accounting_provider_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerCheckoutUrlGenerated
     *
     * A checkout URL was generated for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCheckoutUrlGeneratedRequest|null $customer_checkout_url_generated_request Details of the customer with the generated checkout URL (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCheckoutUrlGenerated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerCheckoutUrlGenerated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request = null, string $contentType = self::contentTypes['customerCheckoutUrlGenerated'][0])
    {
        $this->customerCheckoutUrlGeneratedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request, $contentType);
    }

    /**
     * Operation customerCheckoutUrlGeneratedWithHttpInfo
     *
     * A checkout URL was generated for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCheckoutUrlGeneratedRequest|null $customer_checkout_url_generated_request Details of the customer with the generated checkout URL (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCheckoutUrlGenerated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerCheckoutUrlGeneratedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request = null, string $contentType = self::contentTypes['customerCheckoutUrlGenerated'][0])
    {
        $request = $this->customerCheckoutUrlGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerCheckoutUrlGeneratedAsync
     *
     * A checkout URL was generated for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCheckoutUrlGeneratedRequest|null $customer_checkout_url_generated_request Details of the customer with the generated checkout URL (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCheckoutUrlGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCheckoutUrlGeneratedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request = null, string $contentType = self::contentTypes['customerCheckoutUrlGenerated'][0])
    {
        return $this->customerCheckoutUrlGeneratedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerCheckoutUrlGeneratedAsyncWithHttpInfo
     *
     * A checkout URL was generated for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCheckoutUrlGeneratedRequest|null $customer_checkout_url_generated_request Details of the customer with the generated checkout URL (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCheckoutUrlGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCheckoutUrlGeneratedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request = null, string $contentType = self::contentTypes['customerCheckoutUrlGenerated'][0])
    {
        $returnType = '';
        $request = $this->customerCheckoutUrlGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerCheckoutUrlGenerated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCheckoutUrlGeneratedRequest|null $customer_checkout_url_generated_request Details of the customer with the generated checkout URL (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCheckoutUrlGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerCheckoutUrlGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_checkout_url_generated_request = null, string $contentType = self::contentTypes['customerCheckoutUrlGenerated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerCheckoutUrlGenerated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerCheckoutUrlGenerated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerCheckoutUrlGenerated'
            );
        }



        $resourcePath = '/customer_checkout_url_generated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_checkout_url_generated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_checkout_url_generated_request));
            } else {
                $httpBody = $customer_checkout_url_generated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerCreated
     *
     * A new customer has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCreatedRequest|null $customer_created_request Details of the new customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request = null, string $contentType = self::contentTypes['customerCreated'][0])
    {
        $this->customerCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request, $contentType);
    }

    /**
     * Operation customerCreatedWithHttpInfo
     *
     * A new customer has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCreatedRequest|null $customer_created_request Details of the new customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request = null, string $contentType = self::contentTypes['customerCreated'][0])
    {
        $request = $this->customerCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerCreatedAsync
     *
     * A new customer has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCreatedRequest|null $customer_created_request Details of the new customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request = null, string $contentType = self::contentTypes['customerCreated'][0])
    {
        return $this->customerCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerCreatedAsyncWithHttpInfo
     *
     * A new customer has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCreatedRequest|null $customer_created_request Details of the new customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request = null, string $contentType = self::contentTypes['customerCreated'][0])
    {
        $returnType = '';
        $request = $this->customerCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCreatedRequest|null $customer_created_request Details of the new customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_created_request = null, string $contentType = self::contentTypes['customerCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerCreated'
            );
        }



        $resourcePath = '/customer_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_created_request));
            } else {
                $httpBody = $customer_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerCrmProviderCreated
     *
     * A customer has been created in the CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderCreatedRequest|null $customer_crm_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerCrmProviderCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request = null, string $contentType = self::contentTypes['customerCrmProviderCreated'][0])
    {
        $this->customerCrmProviderCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request, $contentType);
    }

    /**
     * Operation customerCrmProviderCreatedWithHttpInfo
     *
     * A customer has been created in the CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderCreatedRequest|null $customer_crm_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerCrmProviderCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request = null, string $contentType = self::contentTypes['customerCrmProviderCreated'][0])
    {
        $request = $this->customerCrmProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerCrmProviderCreatedAsync
     *
     * A customer has been created in the CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderCreatedRequest|null $customer_crm_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCrmProviderCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request = null, string $contentType = self::contentTypes['customerCrmProviderCreated'][0])
    {
        return $this->customerCrmProviderCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerCrmProviderCreatedAsyncWithHttpInfo
     *
     * A customer has been created in the CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderCreatedRequest|null $customer_crm_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCrmProviderCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request = null, string $contentType = self::contentTypes['customerCrmProviderCreated'][0])
    {
        $returnType = '';
        $request = $this->customerCrmProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerCrmProviderCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderCreatedRequest|null $customer_crm_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerCrmProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_created_request = null, string $contentType = self::contentTypes['customerCrmProviderCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerCrmProviderCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerCrmProviderCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerCrmProviderCreated'
            );
        }



        $resourcePath = '/customer_crm_provider_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_crm_provider_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_crm_provider_created_request));
            } else {
                $httpBody = $customer_crm_provider_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerCrmProviderError
     *
     * An error was encountered while syncing a customer to a CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderErrorRequest|null $customer_crm_provider_error_request Details of the customer and of the CRM provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerCrmProviderError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request = null, string $contentType = self::contentTypes['customerCrmProviderError'][0])
    {
        $this->customerCrmProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request, $contentType);
    }

    /**
     * Operation customerCrmProviderErrorWithHttpInfo
     *
     * An error was encountered while syncing a customer to a CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderErrorRequest|null $customer_crm_provider_error_request Details of the customer and of the CRM provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerCrmProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request = null, string $contentType = self::contentTypes['customerCrmProviderError'][0])
    {
        $request = $this->customerCrmProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerCrmProviderErrorAsync
     *
     * An error was encountered while syncing a customer to a CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderErrorRequest|null $customer_crm_provider_error_request Details of the customer and of the CRM provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCrmProviderErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request = null, string $contentType = self::contentTypes['customerCrmProviderError'][0])
    {
        return $this->customerCrmProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerCrmProviderErrorAsyncWithHttpInfo
     *
     * An error was encountered while syncing a customer to a CRM provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderErrorRequest|null $customer_crm_provider_error_request Details of the customer and of the CRM provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerCrmProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request = null, string $contentType = self::contentTypes['customerCrmProviderError'][0])
    {
        $returnType = '';
        $request = $this->customerCrmProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerCrmProviderError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerCrmProviderErrorRequest|null $customer_crm_provider_error_request Details of the customer and of the CRM provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerCrmProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerCrmProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_crm_provider_error_request = null, string $contentType = self::contentTypes['customerCrmProviderError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerCrmProviderError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerCrmProviderError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerCrmProviderError'
            );
        }



        $resourcePath = '/customer_crm_provider_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_crm_provider_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_crm_provider_error_request));
            } else {
                $httpBody = $customer_crm_provider_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerPaymentProviderCreated
     *
     * A customer has been created on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderCreatedRequest|null $customer_payment_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerPaymentProviderCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request = null, string $contentType = self::contentTypes['customerPaymentProviderCreated'][0])
    {
        $this->customerPaymentProviderCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request, $contentType);
    }

    /**
     * Operation customerPaymentProviderCreatedWithHttpInfo
     *
     * A customer has been created on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderCreatedRequest|null $customer_payment_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerPaymentProviderCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request = null, string $contentType = self::contentTypes['customerPaymentProviderCreated'][0])
    {
        $request = $this->customerPaymentProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerPaymentProviderCreatedAsync
     *
     * A customer has been created on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderCreatedRequest|null $customer_payment_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerPaymentProviderCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request = null, string $contentType = self::contentTypes['customerPaymentProviderCreated'][0])
    {
        return $this->customerPaymentProviderCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerPaymentProviderCreatedAsyncWithHttpInfo
     *
     * A customer has been created on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderCreatedRequest|null $customer_payment_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerPaymentProviderCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request = null, string $contentType = self::contentTypes['customerPaymentProviderCreated'][0])
    {
        $returnType = '';
        $request = $this->customerPaymentProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerPaymentProviderCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderCreatedRequest|null $customer_payment_provider_created_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerPaymentProviderCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_created_request = null, string $contentType = self::contentTypes['customerPaymentProviderCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerPaymentProviderCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerPaymentProviderCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerPaymentProviderCreated'
            );
        }



        $resourcePath = '/customer_payment_provider_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_payment_provider_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_payment_provider_created_request));
            } else {
                $httpBody = $customer_payment_provider_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerPaymentProviderError
     *
     * An error was encountered while syncing a customer to a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderErrorRequest|null $customer_payment_provider_error_request Details of the customer and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerPaymentProviderError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request = null, string $contentType = self::contentTypes['customerPaymentProviderError'][0])
    {
        $this->customerPaymentProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request, $contentType);
    }

    /**
     * Operation customerPaymentProviderErrorWithHttpInfo
     *
     * An error was encountered while syncing a customer to a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderErrorRequest|null $customer_payment_provider_error_request Details of the customer and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerPaymentProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request = null, string $contentType = self::contentTypes['customerPaymentProviderError'][0])
    {
        $request = $this->customerPaymentProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerPaymentProviderErrorAsync
     *
     * An error was encountered while syncing a customer to a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderErrorRequest|null $customer_payment_provider_error_request Details of the customer and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerPaymentProviderErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request = null, string $contentType = self::contentTypes['customerPaymentProviderError'][0])
    {
        return $this->customerPaymentProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerPaymentProviderErrorAsyncWithHttpInfo
     *
     * An error was encountered while syncing a customer to a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderErrorRequest|null $customer_payment_provider_error_request Details of the customer and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerPaymentProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request = null, string $contentType = self::contentTypes['customerPaymentProviderError'][0])
    {
        $returnType = '';
        $request = $this->customerPaymentProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerPaymentProviderError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerPaymentProviderErrorRequest|null $customer_payment_provider_error_request Details of the customer and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerPaymentProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerPaymentProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_payment_provider_error_request = null, string $contentType = self::contentTypes['customerPaymentProviderError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerPaymentProviderError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerPaymentProviderError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerPaymentProviderError'
            );
        }



        $resourcePath = '/customer_payment_provider_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_payment_provider_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_payment_provider_error_request));
            } else {
                $httpBody = $customer_payment_provider_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerTaxProviderError
     *
     * An error was encountered while fetching taxes for a customer on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerTaxProviderErrorRequest|null $customer_tax_provider_error_request Details of the customer and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerTaxProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerTaxProviderError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request = null, string $contentType = self::contentTypes['customerTaxProviderError'][0])
    {
        $this->customerTaxProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request, $contentType);
    }

    /**
     * Operation customerTaxProviderErrorWithHttpInfo
     *
     * An error was encountered while fetching taxes for a customer on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerTaxProviderErrorRequest|null $customer_tax_provider_error_request Details of the customer and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerTaxProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerTaxProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request = null, string $contentType = self::contentTypes['customerTaxProviderError'][0])
    {
        $request = $this->customerTaxProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerTaxProviderErrorAsync
     *
     * An error was encountered while fetching taxes for a customer on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerTaxProviderErrorRequest|null $customer_tax_provider_error_request Details of the customer and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerTaxProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerTaxProviderErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request = null, string $contentType = self::contentTypes['customerTaxProviderError'][0])
    {
        return $this->customerTaxProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerTaxProviderErrorAsyncWithHttpInfo
     *
     * An error was encountered while fetching taxes for a customer on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerTaxProviderErrorRequest|null $customer_tax_provider_error_request Details of the customer and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerTaxProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerTaxProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request = null, string $contentType = self::contentTypes['customerTaxProviderError'][0])
    {
        $returnType = '';
        $request = $this->customerTaxProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerTaxProviderError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerTaxProviderErrorRequest|null $customer_tax_provider_error_request Details of the customer and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerTaxProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerTaxProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_tax_provider_error_request = null, string $contentType = self::contentTypes['customerTaxProviderError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerTaxProviderError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerTaxProviderError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerTaxProviderError'
            );
        }



        $resourcePath = '/customer_tax_provider_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_tax_provider_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_tax_provider_error_request));
            } else {
                $httpBody = $customer_tax_provider_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerUpdated
     *
     * A customer has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerUpdatedRequest|null $customer_updated_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerUpdated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request = null, string $contentType = self::contentTypes['customerUpdated'][0])
    {
        $this->customerUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request, $contentType);
    }

    /**
     * Operation customerUpdatedWithHttpInfo
     *
     * A customer has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerUpdatedRequest|null $customer_updated_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request = null, string $contentType = self::contentTypes['customerUpdated'][0])
    {
        $request = $this->customerUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerUpdatedAsync
     *
     * A customer has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerUpdatedRequest|null $customer_updated_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerUpdatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request = null, string $contentType = self::contentTypes['customerUpdated'][0])
    {
        return $this->customerUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerUpdatedAsyncWithHttpInfo
     *
     * A customer has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerUpdatedRequest|null $customer_updated_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request = null, string $contentType = self::contentTypes['customerUpdated'][0])
    {
        $returnType = '';
        $request = $this->customerUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerUpdated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerUpdatedRequest|null $customer_updated_request Details of the customer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_updated_request = null, string $contentType = self::contentTypes['customerUpdated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerUpdated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerUpdated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerUpdated'
            );
        }



        $resourcePath = '/customer_updated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_updated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_updated_request));
            } else {
                $httpBody = $customer_updated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customerViesCheck
     *
     * VIES VAT number has been checked for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerViesCheckRequest|null $customer_vies_check_request Details of the customer with the VIES VAT check status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerViesCheck'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customerViesCheck($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request = null, string $contentType = self::contentTypes['customerViesCheck'][0])
    {
        $this->customerViesCheckWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request, $contentType);
    }

    /**
     * Operation customerViesCheckWithHttpInfo
     *
     * VIES VAT number has been checked for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerViesCheckRequest|null $customer_vies_check_request Details of the customer with the VIES VAT check status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerViesCheck'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customerViesCheckWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request = null, string $contentType = self::contentTypes['customerViesCheck'][0])
    {
        $request = $this->customerViesCheckRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation customerViesCheckAsync
     *
     * VIES VAT number has been checked for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerViesCheckRequest|null $customer_vies_check_request Details of the customer with the VIES VAT check status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerViesCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerViesCheckAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request = null, string $contentType = self::contentTypes['customerViesCheck'][0])
    {
        return $this->customerViesCheckAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customerViesCheckAsyncWithHttpInfo
     *
     * VIES VAT number has been checked for a customer
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerViesCheckRequest|null $customer_vies_check_request Details of the customer with the VIES VAT check status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerViesCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customerViesCheckAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request = null, string $contentType = self::contentTypes['customerViesCheck'][0])
    {
        $returnType = '';
        $request = $this->customerViesCheckRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customerViesCheck'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\CustomerViesCheckRequest|null $customer_vies_check_request Details of the customer with the VIES VAT check status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['customerViesCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customerViesCheckRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $customer_vies_check_request = null, string $contentType = self::contentTypes['customerViesCheck'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling customerViesCheck'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling customerViesCheck'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling customerViesCheck'
            );
        }



        $resourcePath = '/customer_vies_check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_vies_check_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_vies_check_request));
            } else {
                $httpBody = $customer_vies_check_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventError
     *
     * An error has been detected on an event
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventErrorRequest|null $event_error_request Details of the event and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function eventError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request = null, string $contentType = self::contentTypes['eventError'][0])
    {
        $this->eventErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request, $contentType);
    }

    /**
     * Operation eventErrorWithHttpInfo
     *
     * An error has been detected on an event
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventErrorRequest|null $event_error_request Details of the event and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function eventErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request = null, string $contentType = self::contentTypes['eventError'][0])
    {
        $request = $this->eventErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation eventErrorAsync
     *
     * An error has been detected on an event
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventErrorRequest|null $event_error_request Details of the event and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function eventErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request = null, string $contentType = self::contentTypes['eventError'][0])
    {
        return $this->eventErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventErrorAsyncWithHttpInfo
     *
     * An error has been detected on an event
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventErrorRequest|null $event_error_request Details of the event and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function eventErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request = null, string $contentType = self::contentTypes['eventError'][0])
    {
        $returnType = '';
        $request = $this->eventErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventErrorRequest|null $event_error_request Details of the event and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function eventErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $event_error_request = null, string $contentType = self::contentTypes['eventError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling eventError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling eventError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling eventError'
            );
        }



        $resourcePath = '/event_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($event_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($event_error_request));
            } else {
                $httpBody = $event_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsErrors
     *
     * Errors were encountered while post-processing some events
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventsErrorsRequest|null $events_errors_request Details of the events errors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventsErrors'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function eventsErrors($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request = null, string $contentType = self::contentTypes['eventsErrors'][0])
    {
        $this->eventsErrorsWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request, $contentType);
    }

    /**
     * Operation eventsErrorsWithHttpInfo
     *
     * Errors were encountered while post-processing some events
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventsErrorsRequest|null $events_errors_request Details of the events errors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventsErrors'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsErrorsWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request = null, string $contentType = self::contentTypes['eventsErrors'][0])
    {
        $request = $this->eventsErrorsRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation eventsErrorsAsync
     *
     * Errors were encountered while post-processing some events
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventsErrorsRequest|null $events_errors_request Details of the events errors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventsErrors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsErrorsAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request = null, string $contentType = self::contentTypes['eventsErrors'][0])
    {
        return $this->eventsErrorsAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsErrorsAsyncWithHttpInfo
     *
     * Errors were encountered while post-processing some events
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventsErrorsRequest|null $events_errors_request Details of the events errors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventsErrors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsErrorsAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request = null, string $contentType = self::contentTypes['eventsErrors'][0])
    {
        $returnType = '';
        $request = $this->eventsErrorsRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsErrors'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\EventsErrorsRequest|null $events_errors_request Details of the events errors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['eventsErrors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsErrorsRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $events_errors_request = null, string $contentType = self::contentTypes['eventsErrors'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling eventsErrors'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling eventsErrors'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling eventsErrors'
            );
        }



        $resourcePath = '/events_errors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($events_errors_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($events_errors_request));
            } else {
                $httpBody = $events_errors_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation feeCreated
     *
     * A pay in advance fee has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeCreatedRequest|null $fee_created_request Details of the new fee (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function feeCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request = null, string $contentType = self::contentTypes['feeCreated'][0])
    {
        $this->feeCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request, $contentType);
    }

    /**
     * Operation feeCreatedWithHttpInfo
     *
     * A pay in advance fee has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeCreatedRequest|null $fee_created_request Details of the new fee (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function feeCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request = null, string $contentType = self::contentTypes['feeCreated'][0])
    {
        $request = $this->feeCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation feeCreatedAsync
     *
     * A pay in advance fee has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeCreatedRequest|null $fee_created_request Details of the new fee (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function feeCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request = null, string $contentType = self::contentTypes['feeCreated'][0])
    {
        return $this->feeCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation feeCreatedAsyncWithHttpInfo
     *
     * A pay in advance fee has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeCreatedRequest|null $fee_created_request Details of the new fee (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function feeCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request = null, string $contentType = self::contentTypes['feeCreated'][0])
    {
        $returnType = '';
        $request = $this->feeCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'feeCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeCreatedRequest|null $fee_created_request Details of the new fee (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function feeCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_created_request = null, string $contentType = self::contentTypes['feeCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling feeCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling feeCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling feeCreated'
            );
        }



        $resourcePath = '/fee_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fee_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fee_created_request));
            } else {
                $httpBody = $fee_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation feeTaxProviderError
     *
     * An error was encountered while fetching taxes for a fee on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeTaxProviderErrorRequest|null $fee_tax_provider_error_request Details of the fee and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeTaxProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function feeTaxProviderError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request = null, string $contentType = self::contentTypes['feeTaxProviderError'][0])
    {
        $this->feeTaxProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request, $contentType);
    }

    /**
     * Operation feeTaxProviderErrorWithHttpInfo
     *
     * An error was encountered while fetching taxes for a fee on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeTaxProviderErrorRequest|null $fee_tax_provider_error_request Details of the fee and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeTaxProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function feeTaxProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request = null, string $contentType = self::contentTypes['feeTaxProviderError'][0])
    {
        $request = $this->feeTaxProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation feeTaxProviderErrorAsync
     *
     * An error was encountered while fetching taxes for a fee on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeTaxProviderErrorRequest|null $fee_tax_provider_error_request Details of the fee and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeTaxProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function feeTaxProviderErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request = null, string $contentType = self::contentTypes['feeTaxProviderError'][0])
    {
        return $this->feeTaxProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation feeTaxProviderErrorAsyncWithHttpInfo
     *
     * An error was encountered while fetching taxes for a fee on a tax provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeTaxProviderErrorRequest|null $fee_tax_provider_error_request Details of the fee and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeTaxProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function feeTaxProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request = null, string $contentType = self::contentTypes['feeTaxProviderError'][0])
    {
        $returnType = '';
        $request = $this->feeTaxProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'feeTaxProviderError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\FeeTaxProviderErrorRequest|null $fee_tax_provider_error_request Details of the fee and of the tax provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['feeTaxProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function feeTaxProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $fee_tax_provider_error_request = null, string $contentType = self::contentTypes['feeTaxProviderError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling feeTaxProviderError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling feeTaxProviderError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling feeTaxProviderError'
            );
        }



        $resourcePath = '/fee_tax_provider_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fee_tax_provider_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fee_tax_provider_error_request));
            } else {
                $httpBody = $fee_tax_provider_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation integrationProviderError
     *
     * An error was encountered while processing data on an integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\IntegrationProviderErrorRequest|null $integration_provider_error_request Details of the integration and of the integration error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['integrationProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function integrationProviderError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request = null, string $contentType = self::contentTypes['integrationProviderError'][0])
    {
        $this->integrationProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request, $contentType);
    }

    /**
     * Operation integrationProviderErrorWithHttpInfo
     *
     * An error was encountered while processing data on an integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\IntegrationProviderErrorRequest|null $integration_provider_error_request Details of the integration and of the integration error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['integrationProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function integrationProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request = null, string $contentType = self::contentTypes['integrationProviderError'][0])
    {
        $request = $this->integrationProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation integrationProviderErrorAsync
     *
     * An error was encountered while processing data on an integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\IntegrationProviderErrorRequest|null $integration_provider_error_request Details of the integration and of the integration error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['integrationProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function integrationProviderErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request = null, string $contentType = self::contentTypes['integrationProviderError'][0])
    {
        return $this->integrationProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation integrationProviderErrorAsyncWithHttpInfo
     *
     * An error was encountered while processing data on an integration
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\IntegrationProviderErrorRequest|null $integration_provider_error_request Details of the integration and of the integration error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['integrationProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function integrationProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request = null, string $contentType = self::contentTypes['integrationProviderError'][0])
    {
        $returnType = '';
        $request = $this->integrationProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'integrationProviderError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\IntegrationProviderErrorRequest|null $integration_provider_error_request Details of the integration and of the integration error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['integrationProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function integrationProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $integration_provider_error_request = null, string $contentType = self::contentTypes['integrationProviderError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling integrationProviderError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling integrationProviderError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling integrationProviderError'
            );
        }



        $resourcePath = '/integration_provider_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($integration_provider_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($integration_provider_error_request));
            } else {
                $httpBody = $integration_provider_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceAddOnAdded
     *
     * A new add on invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceAddOnAddedRequest|null $invoice_add_on_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceAddOnAdded'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceAddOnAdded($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request = null, string $contentType = self::contentTypes['invoiceAddOnAdded'][0])
    {
        $this->invoiceAddOnAddedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request, $contentType);
    }

    /**
     * Operation invoiceAddOnAddedWithHttpInfo
     *
     * A new add on invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceAddOnAddedRequest|null $invoice_add_on_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceAddOnAdded'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceAddOnAddedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request = null, string $contentType = self::contentTypes['invoiceAddOnAdded'][0])
    {
        $request = $this->invoiceAddOnAddedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoiceAddOnAddedAsync
     *
     * A new add on invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceAddOnAddedRequest|null $invoice_add_on_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceAddOnAdded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceAddOnAddedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request = null, string $contentType = self::contentTypes['invoiceAddOnAdded'][0])
    {
        return $this->invoiceAddOnAddedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceAddOnAddedAsyncWithHttpInfo
     *
     * A new add on invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceAddOnAddedRequest|null $invoice_add_on_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceAddOnAdded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceAddOnAddedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request = null, string $contentType = self::contentTypes['invoiceAddOnAdded'][0])
    {
        $returnType = '';
        $request = $this->invoiceAddOnAddedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceAddOnAdded'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceAddOnAddedRequest|null $invoice_add_on_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceAddOnAdded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceAddOnAddedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_add_on_added_request = null, string $contentType = self::contentTypes['invoiceAddOnAdded'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoiceAddOnAdded'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoiceAddOnAdded'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoiceAddOnAdded'
            );
        }



        $resourcePath = '/invoice_add_on_added';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_add_on_added_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_add_on_added_request));
            } else {
                $httpBody = $invoice_add_on_added_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceCreated
     *
     * A new invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceCreatedRequest|null $invoice_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request = null, string $contentType = self::contentTypes['invoiceCreated'][0])
    {
        $this->invoiceCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request, $contentType);
    }

    /**
     * Operation invoiceCreatedWithHttpInfo
     *
     * A new invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceCreatedRequest|null $invoice_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request = null, string $contentType = self::contentTypes['invoiceCreated'][0])
    {
        $request = $this->invoiceCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoiceCreatedAsync
     *
     * A new invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceCreatedRequest|null $invoice_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request = null, string $contentType = self::contentTypes['invoiceCreated'][0])
    {
        return $this->invoiceCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceCreatedAsyncWithHttpInfo
     *
     * A new invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceCreatedRequest|null $invoice_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request = null, string $contentType = self::contentTypes['invoiceCreated'][0])
    {
        $returnType = '';
        $request = $this->invoiceCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceCreatedRequest|null $invoice_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_created_request = null, string $contentType = self::contentTypes['invoiceCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoiceCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoiceCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoiceCreated'
            );
        }



        $resourcePath = '/invoice_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_created_request));
            } else {
                $httpBody = $invoice_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceDrafted
     *
     * A new draft invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceDraftedRequest|null $invoice_drafted_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceDrafted'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceDrafted($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request = null, string $contentType = self::contentTypes['invoiceDrafted'][0])
    {
        $this->invoiceDraftedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request, $contentType);
    }

    /**
     * Operation invoiceDraftedWithHttpInfo
     *
     * A new draft invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceDraftedRequest|null $invoice_drafted_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceDrafted'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceDraftedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request = null, string $contentType = self::contentTypes['invoiceDrafted'][0])
    {
        $request = $this->invoiceDraftedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoiceDraftedAsync
     *
     * A new draft invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceDraftedRequest|null $invoice_drafted_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceDrafted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceDraftedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request = null, string $contentType = self::contentTypes['invoiceDrafted'][0])
    {
        return $this->invoiceDraftedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceDraftedAsyncWithHttpInfo
     *
     * A new draft invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceDraftedRequest|null $invoice_drafted_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceDrafted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceDraftedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request = null, string $contentType = self::contentTypes['invoiceDrafted'][0])
    {
        $returnType = '';
        $request = $this->invoiceDraftedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceDrafted'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceDraftedRequest|null $invoice_drafted_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceDrafted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceDraftedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_drafted_request = null, string $contentType = self::contentTypes['invoiceDrafted'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoiceDrafted'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoiceDrafted'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoiceDrafted'
            );
        }



        $resourcePath = '/invoice_drafted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_drafted_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_drafted_request));
            } else {
                $httpBody = $invoice_drafted_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceGenerated
     *
     * A new invoice PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceGeneratedRequest|null $invoice_generated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceGenerated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceGenerated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request = null, string $contentType = self::contentTypes['invoiceGenerated'][0])
    {
        $this->invoiceGeneratedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request, $contentType);
    }

    /**
     * Operation invoiceGeneratedWithHttpInfo
     *
     * A new invoice PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceGeneratedRequest|null $invoice_generated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceGenerated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceGeneratedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request = null, string $contentType = self::contentTypes['invoiceGenerated'][0])
    {
        $request = $this->invoiceGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoiceGeneratedAsync
     *
     * A new invoice PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceGeneratedRequest|null $invoice_generated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceGeneratedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request = null, string $contentType = self::contentTypes['invoiceGenerated'][0])
    {
        return $this->invoiceGeneratedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceGeneratedAsyncWithHttpInfo
     *
     * A new invoice PDF has been generated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceGeneratedRequest|null $invoice_generated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceGeneratedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request = null, string $contentType = self::contentTypes['invoiceGenerated'][0])
    {
        $returnType = '';
        $request = $this->invoiceGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceGenerated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceGeneratedRequest|null $invoice_generated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceGenerated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceGeneratedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_generated_request = null, string $contentType = self::contentTypes['invoiceGenerated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoiceGenerated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoiceGenerated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoiceGenerated'
            );
        }



        $resourcePath = '/invoice_generated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_generated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_generated_request));
            } else {
                $httpBody = $invoice_generated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceOneOffCreated
     *
     * A new one off invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceOneOffCreatedRequest|null $invoice_one_off_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceOneOffCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceOneOffCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request = null, string $contentType = self::contentTypes['invoiceOneOffCreated'][0])
    {
        $this->invoiceOneOffCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request, $contentType);
    }

    /**
     * Operation invoiceOneOffCreatedWithHttpInfo
     *
     * A new one off invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceOneOffCreatedRequest|null $invoice_one_off_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceOneOffCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceOneOffCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request = null, string $contentType = self::contentTypes['invoiceOneOffCreated'][0])
    {
        $request = $this->invoiceOneOffCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoiceOneOffCreatedAsync
     *
     * A new one off invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceOneOffCreatedRequest|null $invoice_one_off_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceOneOffCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceOneOffCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request = null, string $contentType = self::contentTypes['invoiceOneOffCreated'][0])
    {
        return $this->invoiceOneOffCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceOneOffCreatedAsyncWithHttpInfo
     *
     * A new one off invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceOneOffCreatedRequest|null $invoice_one_off_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceOneOffCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceOneOffCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request = null, string $contentType = self::contentTypes['invoiceOneOffCreated'][0])
    {
        $returnType = '';
        $request = $this->invoiceOneOffCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceOneOffCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceOneOffCreatedRequest|null $invoice_one_off_created_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceOneOffCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceOneOffCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_one_off_created_request = null, string $contentType = self::contentTypes['invoiceOneOffCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoiceOneOffCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoiceOneOffCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoiceOneOffCreated'
            );
        }



        $resourcePath = '/invoice_one_off_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_one_off_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_one_off_created_request));
            } else {
                $httpBody = $invoice_one_off_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoicePaidCreditAdded
     *
     * A new prepaid credit invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaidCreditAddedRequest|null $invoice_paid_credit_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaidCreditAdded'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoicePaidCreditAdded($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request = null, string $contentType = self::contentTypes['invoicePaidCreditAdded'][0])
    {
        $this->invoicePaidCreditAddedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request, $contentType);
    }

    /**
     * Operation invoicePaidCreditAddedWithHttpInfo
     *
     * A new prepaid credit invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaidCreditAddedRequest|null $invoice_paid_credit_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaidCreditAdded'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoicePaidCreditAddedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request = null, string $contentType = self::contentTypes['invoicePaidCreditAdded'][0])
    {
        $request = $this->invoicePaidCreditAddedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoicePaidCreditAddedAsync
     *
     * A new prepaid credit invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaidCreditAddedRequest|null $invoice_paid_credit_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaidCreditAdded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaidCreditAddedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request = null, string $contentType = self::contentTypes['invoicePaidCreditAdded'][0])
    {
        return $this->invoicePaidCreditAddedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoicePaidCreditAddedAsyncWithHttpInfo
     *
     * A new prepaid credit invoice has been emitted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaidCreditAddedRequest|null $invoice_paid_credit_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaidCreditAdded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaidCreditAddedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request = null, string $contentType = self::contentTypes['invoicePaidCreditAdded'][0])
    {
        $returnType = '';
        $request = $this->invoicePaidCreditAddedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoicePaidCreditAdded'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaidCreditAddedRequest|null $invoice_paid_credit_added_request Details of the new invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaidCreditAdded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoicePaidCreditAddedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_paid_credit_added_request = null, string $contentType = self::contentTypes['invoicePaidCreditAdded'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoicePaidCreditAdded'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoicePaidCreditAdded'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoicePaidCreditAdded'
            );
        }



        $resourcePath = '/invoice_paid_credit_added';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_paid_credit_added_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_paid_credit_added_request));
            } else {
                $httpBody = $invoice_paid_credit_added_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoicePaymentDisputeLost
     *
     * A payment dispute has been lost for an invoice payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentDisputeLostRequest|null $invoice_payment_dispute_lost_request Details of the invoice and of the payment dispute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentDisputeLost'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoicePaymentDisputeLost($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request = null, string $contentType = self::contentTypes['invoicePaymentDisputeLost'][0])
    {
        $this->invoicePaymentDisputeLostWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request, $contentType);
    }

    /**
     * Operation invoicePaymentDisputeLostWithHttpInfo
     *
     * A payment dispute has been lost for an invoice payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentDisputeLostRequest|null $invoice_payment_dispute_lost_request Details of the invoice and of the payment dispute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentDisputeLost'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoicePaymentDisputeLostWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request = null, string $contentType = self::contentTypes['invoicePaymentDisputeLost'][0])
    {
        $request = $this->invoicePaymentDisputeLostRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoicePaymentDisputeLostAsync
     *
     * A payment dispute has been lost for an invoice payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentDisputeLostRequest|null $invoice_payment_dispute_lost_request Details of the invoice and of the payment dispute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentDisputeLost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentDisputeLostAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request = null, string $contentType = self::contentTypes['invoicePaymentDisputeLost'][0])
    {
        return $this->invoicePaymentDisputeLostAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoicePaymentDisputeLostAsyncWithHttpInfo
     *
     * A payment dispute has been lost for an invoice payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentDisputeLostRequest|null $invoice_payment_dispute_lost_request Details of the invoice and of the payment dispute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentDisputeLost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentDisputeLostAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request = null, string $contentType = self::contentTypes['invoicePaymentDisputeLost'][0])
    {
        $returnType = '';
        $request = $this->invoicePaymentDisputeLostRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoicePaymentDisputeLost'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentDisputeLostRequest|null $invoice_payment_dispute_lost_request Details of the invoice and of the payment dispute (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentDisputeLost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoicePaymentDisputeLostRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_dispute_lost_request = null, string $contentType = self::contentTypes['invoicePaymentDisputeLost'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoicePaymentDisputeLost'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoicePaymentDisputeLost'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoicePaymentDisputeLost'
            );
        }



        $resourcePath = '/invoice_payment_dispute_lost';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_payment_dispute_lost_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_payment_dispute_lost_request));
            } else {
                $httpBody = $invoice_payment_dispute_lost_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoicePaymentFailure
     *
     * A payment attempt for an invoice has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentFailureRequest|null $invoice_payment_failure_request Details of the invoice and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoicePaymentFailure($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request = null, string $contentType = self::contentTypes['invoicePaymentFailure'][0])
    {
        $this->invoicePaymentFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request, $contentType);
    }

    /**
     * Operation invoicePaymentFailureWithHttpInfo
     *
     * A payment attempt for an invoice has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentFailureRequest|null $invoice_payment_failure_request Details of the invoice and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoicePaymentFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request = null, string $contentType = self::contentTypes['invoicePaymentFailure'][0])
    {
        $request = $this->invoicePaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoicePaymentFailureAsync
     *
     * A payment attempt for an invoice has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentFailureRequest|null $invoice_payment_failure_request Details of the invoice and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentFailureAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request = null, string $contentType = self::contentTypes['invoicePaymentFailure'][0])
    {
        return $this->invoicePaymentFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoicePaymentFailureAsyncWithHttpInfo
     *
     * A payment attempt for an invoice has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentFailureRequest|null $invoice_payment_failure_request Details of the invoice and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request = null, string $contentType = self::contentTypes['invoicePaymentFailure'][0])
    {
        $returnType = '';
        $request = $this->invoicePaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoicePaymentFailure'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentFailureRequest|null $invoice_payment_failure_request Details of the invoice and of the payment provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoicePaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_failure_request = null, string $contentType = self::contentTypes['invoicePaymentFailure'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoicePaymentFailure'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoicePaymentFailure'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoicePaymentFailure'
            );
        }



        $resourcePath = '/invoice_payment_failure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_payment_failure_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_payment_failure_request));
            } else {
                $httpBody = $invoice_payment_failure_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoicePaymentOverdue
     *
     * An invoice payment is overdue
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentOverdueRequest|null $invoice_payment_overdue_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentOverdue'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoicePaymentOverdue($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request = null, string $contentType = self::contentTypes['invoicePaymentOverdue'][0])
    {
        $this->invoicePaymentOverdueWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request, $contentType);
    }

    /**
     * Operation invoicePaymentOverdueWithHttpInfo
     *
     * An invoice payment is overdue
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentOverdueRequest|null $invoice_payment_overdue_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentOverdue'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoicePaymentOverdueWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request = null, string $contentType = self::contentTypes['invoicePaymentOverdue'][0])
    {
        $request = $this->invoicePaymentOverdueRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoicePaymentOverdueAsync
     *
     * An invoice payment is overdue
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentOverdueRequest|null $invoice_payment_overdue_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentOverdue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentOverdueAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request = null, string $contentType = self::contentTypes['invoicePaymentOverdue'][0])
    {
        return $this->invoicePaymentOverdueAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoicePaymentOverdueAsyncWithHttpInfo
     *
     * An invoice payment is overdue
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentOverdueRequest|null $invoice_payment_overdue_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentOverdue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentOverdueAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request = null, string $contentType = self::contentTypes['invoicePaymentOverdue'][0])
    {
        $returnType = '';
        $request = $this->invoicePaymentOverdueRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoicePaymentOverdue'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentOverdueRequest|null $invoice_payment_overdue_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentOverdue'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoicePaymentOverdueRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_overdue_request = null, string $contentType = self::contentTypes['invoicePaymentOverdue'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoicePaymentOverdue'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoicePaymentOverdue'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoicePaymentOverdue'
            );
        }



        $resourcePath = '/invoice_payment_overdue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_payment_overdue_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_payment_overdue_request));
            } else {
                $httpBody = $invoice_payment_overdue_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoicePaymentStatusUpdated
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentStatusUpdatedRequest|null $invoice_payment_status_updated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoicePaymentStatusUpdated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request = null, string $contentType = self::contentTypes['invoicePaymentStatusUpdated'][0])
    {
        $this->invoicePaymentStatusUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request, $contentType);
    }

    /**
     * Operation invoicePaymentStatusUpdatedWithHttpInfo
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentStatusUpdatedRequest|null $invoice_payment_status_updated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoicePaymentStatusUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request = null, string $contentType = self::contentTypes['invoicePaymentStatusUpdated'][0])
    {
        $request = $this->invoicePaymentStatusUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoicePaymentStatusUpdatedAsync
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentStatusUpdatedRequest|null $invoice_payment_status_updated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentStatusUpdatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request = null, string $contentType = self::contentTypes['invoicePaymentStatusUpdated'][0])
    {
        return $this->invoicePaymentStatusUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoicePaymentStatusUpdatedAsyncWithHttpInfo
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentStatusUpdatedRequest|null $invoice_payment_status_updated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoicePaymentStatusUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request = null, string $contentType = self::contentTypes['invoicePaymentStatusUpdated'][0])
    {
        $returnType = '';
        $request = $this->invoicePaymentStatusUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoicePaymentStatusUpdated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoicePaymentStatusUpdatedRequest|null $invoice_payment_status_updated_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoicePaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoicePaymentStatusUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_payment_status_updated_request = null, string $contentType = self::contentTypes['invoicePaymentStatusUpdated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoicePaymentStatusUpdated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoicePaymentStatusUpdated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoicePaymentStatusUpdated'
            );
        }



        $resourcePath = '/invoice_payment_status_updated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_payment_status_updated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_payment_status_updated_request));
            } else {
                $httpBody = $invoice_payment_status_updated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceResynced
     *
     * An invoice has been resynced with salesforce
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceResyncedRequest|null $invoice_resynced_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceResynced'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceResynced($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request = null, string $contentType = self::contentTypes['invoiceResynced'][0])
    {
        $this->invoiceResyncedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request, $contentType);
    }

    /**
     * Operation invoiceResyncedWithHttpInfo
     *
     * An invoice has been resynced with salesforce
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceResyncedRequest|null $invoice_resynced_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceResynced'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceResyncedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request = null, string $contentType = self::contentTypes['invoiceResynced'][0])
    {
        $request = $this->invoiceResyncedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoiceResyncedAsync
     *
     * An invoice has been resynced with salesforce
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceResyncedRequest|null $invoice_resynced_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceResynced'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceResyncedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request = null, string $contentType = self::contentTypes['invoiceResynced'][0])
    {
        return $this->invoiceResyncedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceResyncedAsyncWithHttpInfo
     *
     * An invoice has been resynced with salesforce
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceResyncedRequest|null $invoice_resynced_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceResynced'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceResyncedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request = null, string $contentType = self::contentTypes['invoiceResynced'][0])
    {
        $returnType = '';
        $request = $this->invoiceResyncedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceResynced'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceResyncedRequest|null $invoice_resynced_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceResynced'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceResyncedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_resynced_request = null, string $contentType = self::contentTypes['invoiceResynced'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoiceResynced'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoiceResynced'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoiceResynced'
            );
        }



        $resourcePath = '/invoice_resynced';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_resynced_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_resynced_request));
            } else {
                $httpBody = $invoice_resynced_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invoiceVoided
     *
     * An invoice has been voided
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceVoidedRequest|null $invoice_voided_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceVoided'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function invoiceVoided($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request = null, string $contentType = self::contentTypes['invoiceVoided'][0])
    {
        $this->invoiceVoidedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request, $contentType);
    }

    /**
     * Operation invoiceVoidedWithHttpInfo
     *
     * An invoice has been voided
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceVoidedRequest|null $invoice_voided_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceVoided'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function invoiceVoidedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request = null, string $contentType = self::contentTypes['invoiceVoided'][0])
    {
        $request = $this->invoiceVoidedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation invoiceVoidedAsync
     *
     * An invoice has been voided
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceVoidedRequest|null $invoice_voided_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceVoided'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceVoidedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request = null, string $contentType = self::contentTypes['invoiceVoided'][0])
    {
        return $this->invoiceVoidedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invoiceVoidedAsyncWithHttpInfo
     *
     * An invoice has been voided
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceVoidedRequest|null $invoice_voided_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceVoided'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invoiceVoidedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request = null, string $contentType = self::contentTypes['invoiceVoided'][0])
    {
        $returnType = '';
        $request = $this->invoiceVoidedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invoiceVoided'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\InvoiceVoidedRequest|null $invoice_voided_request Details of the invoice (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['invoiceVoided'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function invoiceVoidedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $invoice_voided_request = null, string $contentType = self::contentTypes['invoiceVoided'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling invoiceVoided'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling invoiceVoided'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling invoiceVoided'
            );
        }



        $resourcePath = '/invoice_voided';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_voided_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_voided_request));
            } else {
                $httpBody = $invoice_voided_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentProviderError
     *
     * An error was raised by a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentProviderErrorRequest|null $payment_provider_error_request Details of the payment provider and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function paymentProviderError($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request = null, string $contentType = self::contentTypes['paymentProviderError'][0])
    {
        $this->paymentProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request, $contentType);
    }

    /**
     * Operation paymentProviderErrorWithHttpInfo
     *
     * An error was raised by a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentProviderErrorRequest|null $payment_provider_error_request Details of the payment provider and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentProviderError'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentProviderErrorWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request = null, string $contentType = self::contentTypes['paymentProviderError'][0])
    {
        $request = $this->paymentProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation paymentProviderErrorAsync
     *
     * An error was raised by a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentProviderErrorRequest|null $payment_provider_error_request Details of the payment provider and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentProviderErrorAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request = null, string $contentType = self::contentTypes['paymentProviderError'][0])
    {
        return $this->paymentProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentProviderErrorAsyncWithHttpInfo
     *
     * An error was raised by a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentProviderErrorRequest|null $payment_provider_error_request Details of the payment provider and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentProviderErrorAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request = null, string $contentType = self::contentTypes['paymentProviderError'][0])
    {
        $returnType = '';
        $request = $this->paymentProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentProviderError'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentProviderErrorRequest|null $payment_provider_error_request Details of the payment provider and of the error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentProviderError'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentProviderErrorRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_provider_error_request = null, string $contentType = self::contentTypes['paymentProviderError'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling paymentProviderError'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling paymentProviderError'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling paymentProviderError'
            );
        }



        $resourcePath = '/payment_provider_error';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_provider_error_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_provider_error_request));
            } else {
                $httpBody = $payment_provider_error_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentRequestCreated
     *
     * An new payment request has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestCreatedRequest|null $payment_request_created_request Details of the new payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function paymentRequestCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request = null, string $contentType = self::contentTypes['paymentRequestCreated'][0])
    {
        $this->paymentRequestCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request, $contentType);
    }

    /**
     * Operation paymentRequestCreatedWithHttpInfo
     *
     * An new payment request has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestCreatedRequest|null $payment_request_created_request Details of the new payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentRequestCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request = null, string $contentType = self::contentTypes['paymentRequestCreated'][0])
    {
        $request = $this->paymentRequestCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation paymentRequestCreatedAsync
     *
     * An new payment request has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestCreatedRequest|null $payment_request_created_request Details of the new payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequestCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request = null, string $contentType = self::contentTypes['paymentRequestCreated'][0])
    {
        return $this->paymentRequestCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentRequestCreatedAsyncWithHttpInfo
     *
     * An new payment request has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestCreatedRequest|null $payment_request_created_request Details of the new payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequestCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request = null, string $contentType = self::contentTypes['paymentRequestCreated'][0])
    {
        $returnType = '';
        $request = $this->paymentRequestCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentRequestCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestCreatedRequest|null $payment_request_created_request Details of the new payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentRequestCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_created_request = null, string $contentType = self::contentTypes['paymentRequestCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling paymentRequestCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling paymentRequestCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling paymentRequestCreated'
            );
        }



        $resourcePath = '/payment_request_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_request_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_request_created_request));
            } else {
                $httpBody = $payment_request_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentRequestPaymentFailure
     *
     * A payment attempt for a payment request has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentFailureRequest|null $payment_request_payment_failure_request Details of the payment request and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function paymentRequestPaymentFailure($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request = null, string $contentType = self::contentTypes['paymentRequestPaymentFailure'][0])
    {
        $this->paymentRequestPaymentFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request, $contentType);
    }

    /**
     * Operation paymentRequestPaymentFailureWithHttpInfo
     *
     * A payment attempt for a payment request has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentFailureRequest|null $payment_request_payment_failure_request Details of the payment request and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentRequestPaymentFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request = null, string $contentType = self::contentTypes['paymentRequestPaymentFailure'][0])
    {
        $request = $this->paymentRequestPaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation paymentRequestPaymentFailureAsync
     *
     * A payment attempt for a payment request has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentFailureRequest|null $payment_request_payment_failure_request Details of the payment request and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequestPaymentFailureAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request = null, string $contentType = self::contentTypes['paymentRequestPaymentFailure'][0])
    {
        return $this->paymentRequestPaymentFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentRequestPaymentFailureAsyncWithHttpInfo
     *
     * A payment attempt for a payment request has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentFailureRequest|null $payment_request_payment_failure_request Details of the payment request and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequestPaymentFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request = null, string $contentType = self::contentTypes['paymentRequestPaymentFailure'][0])
    {
        $returnType = '';
        $request = $this->paymentRequestPaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentRequestPaymentFailure'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentFailureRequest|null $payment_request_payment_failure_request Details of the payment request and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentRequestPaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_failure_request = null, string $contentType = self::contentTypes['paymentRequestPaymentFailure'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling paymentRequestPaymentFailure'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling paymentRequestPaymentFailure'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling paymentRequestPaymentFailure'
            );
        }



        $resourcePath = '/payment_request_payment_failure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_request_payment_failure_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_request_payment_failure_request));
            } else {
                $httpBody = $payment_request_payment_failure_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentRequestPaymentStatusUpdated
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentStatusUpdatedRequest|null $payment_request_payment_status_updated_request Details of the payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function paymentRequestPaymentStatusUpdated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request = null, string $contentType = self::contentTypes['paymentRequestPaymentStatusUpdated'][0])
    {
        $this->paymentRequestPaymentStatusUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request, $contentType);
    }

    /**
     * Operation paymentRequestPaymentStatusUpdatedWithHttpInfo
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentStatusUpdatedRequest|null $payment_request_payment_status_updated_request Details of the payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentRequestPaymentStatusUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request = null, string $contentType = self::contentTypes['paymentRequestPaymentStatusUpdated'][0])
    {
        $request = $this->paymentRequestPaymentStatusUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation paymentRequestPaymentStatusUpdatedAsync
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentStatusUpdatedRequest|null $payment_request_payment_status_updated_request Details of the payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequestPaymentStatusUpdatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request = null, string $contentType = self::contentTypes['paymentRequestPaymentStatusUpdated'][0])
    {
        return $this->paymentRequestPaymentStatusUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentRequestPaymentStatusUpdatedAsyncWithHttpInfo
     *
     * The payment status of an invoice has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentStatusUpdatedRequest|null $payment_request_payment_status_updated_request Details of the payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequestPaymentStatusUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request = null, string $contentType = self::contentTypes['paymentRequestPaymentStatusUpdated'][0])
    {
        $returnType = '';
        $request = $this->paymentRequestPaymentStatusUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentRequestPaymentStatusUpdated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequestPaymentStatusUpdatedRequest|null $payment_request_payment_status_updated_request Details of the payment request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequestPaymentStatusUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentRequestPaymentStatusUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_request_payment_status_updated_request = null, string $contentType = self::contentTypes['paymentRequestPaymentStatusUpdated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling paymentRequestPaymentStatusUpdated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling paymentRequestPaymentStatusUpdated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling paymentRequestPaymentStatusUpdated'
            );
        }



        $resourcePath = '/payment_request_payment_status_updated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_request_payment_status_updated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_request_payment_status_updated_request));
            } else {
                $httpBody = $payment_request_payment_status_updated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentRequiresAction
     *
     * An action is required to process a payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequiresActionRequest|null $payment_requires_action_request Details of the payment and of the required action (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequiresAction'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function paymentRequiresAction($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request = null, string $contentType = self::contentTypes['paymentRequiresAction'][0])
    {
        $this->paymentRequiresActionWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request, $contentType);
    }

    /**
     * Operation paymentRequiresActionWithHttpInfo
     *
     * An action is required to process a payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequiresActionRequest|null $payment_requires_action_request Details of the payment and of the required action (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequiresAction'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentRequiresActionWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request = null, string $contentType = self::contentTypes['paymentRequiresAction'][0])
    {
        $request = $this->paymentRequiresActionRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation paymentRequiresActionAsync
     *
     * An action is required to process a payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequiresActionRequest|null $payment_requires_action_request Details of the payment and of the required action (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequiresAction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequiresActionAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request = null, string $contentType = self::contentTypes['paymentRequiresAction'][0])
    {
        return $this->paymentRequiresActionAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentRequiresActionAsyncWithHttpInfo
     *
     * An action is required to process a payment
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequiresActionRequest|null $payment_requires_action_request Details of the payment and of the required action (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequiresAction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function paymentRequiresActionAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request = null, string $contentType = self::contentTypes['paymentRequiresAction'][0])
    {
        $returnType = '';
        $request = $this->paymentRequiresActionRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentRequiresAction'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PaymentRequiresActionRequest|null $payment_requires_action_request Details of the payment and of the required action (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentRequiresAction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentRequiresActionRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $payment_requires_action_request = null, string $contentType = self::contentTypes['paymentRequiresAction'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling paymentRequiresAction'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling paymentRequiresAction'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling paymentRequiresAction'
            );
        }



        $resourcePath = '/payment_requires_action';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_requires_action_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_requires_action_request));
            } else {
                $httpBody = $payment_requires_action_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation planCreated
     *
     * A new plan has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanCreatedRequest|null $plan_created_request Details of the new plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function planCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request = null, string $contentType = self::contentTypes['planCreated'][0])
    {
        $this->planCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request, $contentType);
    }

    /**
     * Operation planCreatedWithHttpInfo
     *
     * A new plan has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanCreatedRequest|null $plan_created_request Details of the new plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function planCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request = null, string $contentType = self::contentTypes['planCreated'][0])
    {
        $request = $this->planCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation planCreatedAsync
     *
     * A new plan has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanCreatedRequest|null $plan_created_request Details of the new plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request = null, string $contentType = self::contentTypes['planCreated'][0])
    {
        return $this->planCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation planCreatedAsyncWithHttpInfo
     *
     * A new plan has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanCreatedRequest|null $plan_created_request Details of the new plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request = null, string $contentType = self::contentTypes['planCreated'][0])
    {
        $returnType = '';
        $request = $this->planCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'planCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanCreatedRequest|null $plan_created_request Details of the new plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function planCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_created_request = null, string $contentType = self::contentTypes['planCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling planCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling planCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling planCreated'
            );
        }



        $resourcePath = '/plan_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($plan_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($plan_created_request));
            } else {
                $httpBody = $plan_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation planDeleted
     *
     * A plan has been deleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanDeletedRequest|null $plan_deleted_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planDeleted'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function planDeleted($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request = null, string $contentType = self::contentTypes['planDeleted'][0])
    {
        $this->planDeletedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request, $contentType);
    }

    /**
     * Operation planDeletedWithHttpInfo
     *
     * A plan has been deleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanDeletedRequest|null $plan_deleted_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planDeleted'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function planDeletedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request = null, string $contentType = self::contentTypes['planDeleted'][0])
    {
        $request = $this->planDeletedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation planDeletedAsync
     *
     * A plan has been deleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanDeletedRequest|null $plan_deleted_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planDeleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planDeletedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request = null, string $contentType = self::contentTypes['planDeleted'][0])
    {
        return $this->planDeletedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation planDeletedAsyncWithHttpInfo
     *
     * A plan has been deleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanDeletedRequest|null $plan_deleted_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planDeleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planDeletedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request = null, string $contentType = self::contentTypes['planDeleted'][0])
    {
        $returnType = '';
        $request = $this->planDeletedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'planDeleted'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanDeletedRequest|null $plan_deleted_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planDeleted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function planDeletedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_deleted_request = null, string $contentType = self::contentTypes['planDeleted'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling planDeleted'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling planDeleted'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling planDeleted'
            );
        }



        $resourcePath = '/plan_deleted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($plan_deleted_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($plan_deleted_request));
            } else {
                $httpBody = $plan_deleted_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation planUpdated
     *
     * A plan has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanUpdatedRequest|null $plan_updated_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function planUpdated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request = null, string $contentType = self::contentTypes['planUpdated'][0])
    {
        $this->planUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request, $contentType);
    }

    /**
     * Operation planUpdatedWithHttpInfo
     *
     * A plan has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanUpdatedRequest|null $plan_updated_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function planUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request = null, string $contentType = self::contentTypes['planUpdated'][0])
    {
        $request = $this->planUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation planUpdatedAsync
     *
     * A plan has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanUpdatedRequest|null $plan_updated_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planUpdatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request = null, string $contentType = self::contentTypes['planUpdated'][0])
    {
        return $this->planUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation planUpdatedAsyncWithHttpInfo
     *
     * A plan has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanUpdatedRequest|null $plan_updated_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function planUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request = null, string $contentType = self::contentTypes['planUpdated'][0])
    {
        $returnType = '';
        $request = $this->planUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'planUpdated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\PlanUpdatedRequest|null $plan_updated_request Details of the plan (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['planUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function planUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $plan_updated_request = null, string $contentType = self::contentTypes['planUpdated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling planUpdated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling planUpdated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling planUpdated'
            );
        }



        $resourcePath = '/plan_updated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($plan_updated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($plan_updated_request));
            } else {
                $httpBody = $plan_updated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subscriptionStarted
     *
     * An subscription has started
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionStartedRequest|null $subscription_started_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionStarted'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function subscriptionStarted($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request = null, string $contentType = self::contentTypes['subscriptionStarted'][0])
    {
        $this->subscriptionStartedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request, $contentType);
    }

    /**
     * Operation subscriptionStartedWithHttpInfo
     *
     * An subscription has started
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionStartedRequest|null $subscription_started_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionStarted'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function subscriptionStartedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request = null, string $contentType = self::contentTypes['subscriptionStarted'][0])
    {
        $request = $this->subscriptionStartedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation subscriptionStartedAsync
     *
     * An subscription has started
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionStartedRequest|null $subscription_started_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionStarted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionStartedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request = null, string $contentType = self::contentTypes['subscriptionStarted'][0])
    {
        return $this->subscriptionStartedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subscriptionStartedAsyncWithHttpInfo
     *
     * An subscription has started
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionStartedRequest|null $subscription_started_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionStarted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionStartedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request = null, string $contentType = self::contentTypes['subscriptionStarted'][0])
    {
        $returnType = '';
        $request = $this->subscriptionStartedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subscriptionStarted'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionStartedRequest|null $subscription_started_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionStarted'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subscriptionStartedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_started_request = null, string $contentType = self::contentTypes['subscriptionStarted'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling subscriptionStarted'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling subscriptionStarted'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling subscriptionStarted'
            );
        }



        $resourcePath = '/subscription_started';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_started_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_started_request));
            } else {
                $httpBody = $subscription_started_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subscriptionTerminated
     *
     * A subscription has been terminated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminatedRequest|null $subscription_terminated_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function subscriptionTerminated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request = null, string $contentType = self::contentTypes['subscriptionTerminated'][0])
    {
        $this->subscriptionTerminatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request, $contentType);
    }

    /**
     * Operation subscriptionTerminatedWithHttpInfo
     *
     * A subscription has been terminated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminatedRequest|null $subscription_terminated_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function subscriptionTerminatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request = null, string $contentType = self::contentTypes['subscriptionTerminated'][0])
    {
        $request = $this->subscriptionTerminatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation subscriptionTerminatedAsync
     *
     * A subscription has been terminated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminatedRequest|null $subscription_terminated_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionTerminatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request = null, string $contentType = self::contentTypes['subscriptionTerminated'][0])
    {
        return $this->subscriptionTerminatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subscriptionTerminatedAsyncWithHttpInfo
     *
     * A subscription has been terminated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminatedRequest|null $subscription_terminated_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionTerminatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request = null, string $contentType = self::contentTypes['subscriptionTerminated'][0])
    {
        $returnType = '';
        $request = $this->subscriptionTerminatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subscriptionTerminated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminatedRequest|null $subscription_terminated_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subscriptionTerminatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_terminated_request = null, string $contentType = self::contentTypes['subscriptionTerminated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling subscriptionTerminated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling subscriptionTerminated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling subscriptionTerminated'
            );
        }



        $resourcePath = '/subscription_terminated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_terminated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_terminated_request));
            } else {
                $httpBody = $subscription_terminated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subscriptionTerminationAlert
     *
     * A subscription will be terminated in the future
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminationAlertRequest|null $subscription_termination_alert_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminationAlert'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function subscriptionTerminationAlert($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request = null, string $contentType = self::contentTypes['subscriptionTerminationAlert'][0])
    {
        $this->subscriptionTerminationAlertWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request, $contentType);
    }

    /**
     * Operation subscriptionTerminationAlertWithHttpInfo
     *
     * A subscription will be terminated in the future
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminationAlertRequest|null $subscription_termination_alert_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminationAlert'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function subscriptionTerminationAlertWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request = null, string $contentType = self::contentTypes['subscriptionTerminationAlert'][0])
    {
        $request = $this->subscriptionTerminationAlertRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation subscriptionTerminationAlertAsync
     *
     * A subscription will be terminated in the future
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminationAlertRequest|null $subscription_termination_alert_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminationAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionTerminationAlertAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request = null, string $contentType = self::contentTypes['subscriptionTerminationAlert'][0])
    {
        return $this->subscriptionTerminationAlertAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subscriptionTerminationAlertAsyncWithHttpInfo
     *
     * A subscription will be terminated in the future
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminationAlertRequest|null $subscription_termination_alert_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminationAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionTerminationAlertAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request = null, string $contentType = self::contentTypes['subscriptionTerminationAlert'][0])
    {
        $returnType = '';
        $request = $this->subscriptionTerminationAlertRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subscriptionTerminationAlert'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTerminationAlertRequest|null $subscription_termination_alert_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTerminationAlert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subscriptionTerminationAlertRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_termination_alert_request = null, string $contentType = self::contentTypes['subscriptionTerminationAlert'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling subscriptionTerminationAlert'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling subscriptionTerminationAlert'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling subscriptionTerminationAlert'
            );
        }



        $resourcePath = '/subscription_termination_alert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_termination_alert_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_termination_alert_request));
            } else {
                $httpBody = $subscription_termination_alert_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subscriptionTrialEnded
     *
     * A subscription trial period has ended
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTrialEndedRequest|null $subscription_trial_ended_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTrialEnded'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function subscriptionTrialEnded($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request = null, string $contentType = self::contentTypes['subscriptionTrialEnded'][0])
    {
        $this->subscriptionTrialEndedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request, $contentType);
    }

    /**
     * Operation subscriptionTrialEndedWithHttpInfo
     *
     * A subscription trial period has ended
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTrialEndedRequest|null $subscription_trial_ended_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTrialEnded'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function subscriptionTrialEndedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request = null, string $contentType = self::contentTypes['subscriptionTrialEnded'][0])
    {
        $request = $this->subscriptionTrialEndedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation subscriptionTrialEndedAsync
     *
     * A subscription trial period has ended
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTrialEndedRequest|null $subscription_trial_ended_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTrialEnded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionTrialEndedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request = null, string $contentType = self::contentTypes['subscriptionTrialEnded'][0])
    {
        return $this->subscriptionTrialEndedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subscriptionTrialEndedAsyncWithHttpInfo
     *
     * A subscription trial period has ended
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTrialEndedRequest|null $subscription_trial_ended_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTrialEnded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionTrialEndedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request = null, string $contentType = self::contentTypes['subscriptionTrialEnded'][0])
    {
        $returnType = '';
        $request = $this->subscriptionTrialEndedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subscriptionTrialEnded'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionTrialEndedRequest|null $subscription_trial_ended_request Details of the subscription (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionTrialEnded'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subscriptionTrialEndedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_trial_ended_request = null, string $contentType = self::contentTypes['subscriptionTrialEnded'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling subscriptionTrialEnded'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling subscriptionTrialEnded'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling subscriptionTrialEnded'
            );
        }



        $resourcePath = '/subscription_trial_ended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_trial_ended_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_trial_ended_request));
            } else {
                $httpBody = $subscription_trial_ended_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subscriptionUsageThresholdReached
     *
     * A usage threshold has been reached by a subscription
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionUsageThresholdReachedRequest|null $subscription_usage_threshold_reached_request Details of the subscription and of the reached threshold (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionUsageThresholdReached'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function subscriptionUsageThresholdReached($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request = null, string $contentType = self::contentTypes['subscriptionUsageThresholdReached'][0])
    {
        $this->subscriptionUsageThresholdReachedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request, $contentType);
    }

    /**
     * Operation subscriptionUsageThresholdReachedWithHttpInfo
     *
     * A usage threshold has been reached by a subscription
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionUsageThresholdReachedRequest|null $subscription_usage_threshold_reached_request Details of the subscription and of the reached threshold (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionUsageThresholdReached'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function subscriptionUsageThresholdReachedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request = null, string $contentType = self::contentTypes['subscriptionUsageThresholdReached'][0])
    {
        $request = $this->subscriptionUsageThresholdReachedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation subscriptionUsageThresholdReachedAsync
     *
     * A usage threshold has been reached by a subscription
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionUsageThresholdReachedRequest|null $subscription_usage_threshold_reached_request Details of the subscription and of the reached threshold (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionUsageThresholdReached'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionUsageThresholdReachedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request = null, string $contentType = self::contentTypes['subscriptionUsageThresholdReached'][0])
    {
        return $this->subscriptionUsageThresholdReachedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subscriptionUsageThresholdReachedAsyncWithHttpInfo
     *
     * A usage threshold has been reached by a subscription
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionUsageThresholdReachedRequest|null $subscription_usage_threshold_reached_request Details of the subscription and of the reached threshold (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionUsageThresholdReached'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subscriptionUsageThresholdReachedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request = null, string $contentType = self::contentTypes['subscriptionUsageThresholdReached'][0])
    {
        $returnType = '';
        $request = $this->subscriptionUsageThresholdReachedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subscriptionUsageThresholdReached'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\SubscriptionUsageThresholdReachedRequest|null $subscription_usage_threshold_reached_request Details of the subscription and of the reached threshold (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subscriptionUsageThresholdReached'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subscriptionUsageThresholdReachedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $subscription_usage_threshold_reached_request = null, string $contentType = self::contentTypes['subscriptionUsageThresholdReached'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling subscriptionUsageThresholdReached'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling subscriptionUsageThresholdReached'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling subscriptionUsageThresholdReached'
            );
        }



        $resourcePath = '/subscription_usage_threshold_reached';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($subscription_usage_threshold_reached_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($subscription_usage_threshold_reached_request));
            } else {
                $httpBody = $subscription_usage_threshold_reached_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation walletDepletedOngoingBalance
     *
     * The balance of a wallet has been depleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletDepletedOngoingBalanceRequest|null $wallet_depleted_ongoing_balance_request Details of the wallet (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletDepletedOngoingBalance'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function walletDepletedOngoingBalance($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request = null, string $contentType = self::contentTypes['walletDepletedOngoingBalance'][0])
    {
        $this->walletDepletedOngoingBalanceWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request, $contentType);
    }

    /**
     * Operation walletDepletedOngoingBalanceWithHttpInfo
     *
     * The balance of a wallet has been depleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletDepletedOngoingBalanceRequest|null $wallet_depleted_ongoing_balance_request Details of the wallet (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletDepletedOngoingBalance'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function walletDepletedOngoingBalanceWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request = null, string $contentType = self::contentTypes['walletDepletedOngoingBalance'][0])
    {
        $request = $this->walletDepletedOngoingBalanceRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation walletDepletedOngoingBalanceAsync
     *
     * The balance of a wallet has been depleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletDepletedOngoingBalanceRequest|null $wallet_depleted_ongoing_balance_request Details of the wallet (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletDepletedOngoingBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletDepletedOngoingBalanceAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request = null, string $contentType = self::contentTypes['walletDepletedOngoingBalance'][0])
    {
        return $this->walletDepletedOngoingBalanceAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation walletDepletedOngoingBalanceAsyncWithHttpInfo
     *
     * The balance of a wallet has been depleted
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletDepletedOngoingBalanceRequest|null $wallet_depleted_ongoing_balance_request Details of the wallet (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletDepletedOngoingBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletDepletedOngoingBalanceAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request = null, string $contentType = self::contentTypes['walletDepletedOngoingBalance'][0])
    {
        $returnType = '';
        $request = $this->walletDepletedOngoingBalanceRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'walletDepletedOngoingBalance'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletDepletedOngoingBalanceRequest|null $wallet_depleted_ongoing_balance_request Details of the wallet (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletDepletedOngoingBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function walletDepletedOngoingBalanceRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_depleted_ongoing_balance_request = null, string $contentType = self::contentTypes['walletDepletedOngoingBalance'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling walletDepletedOngoingBalance'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling walletDepletedOngoingBalance'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling walletDepletedOngoingBalance'
            );
        }



        $resourcePath = '/wallet_depleted_ongoing_balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wallet_depleted_ongoing_balance_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wallet_depleted_ongoing_balance_request));
            } else {
                $httpBody = $wallet_depleted_ongoing_balance_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation walletTransactionCreated
     *
     * A new wallet transaction has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionCreatedRequest|null $wallet_transaction_created_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function walletTransactionCreated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request = null, string $contentType = self::contentTypes['walletTransactionCreated'][0])
    {
        $this->walletTransactionCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request, $contentType);
    }

    /**
     * Operation walletTransactionCreatedWithHttpInfo
     *
     * A new wallet transaction has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionCreatedRequest|null $wallet_transaction_created_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionCreated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function walletTransactionCreatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request = null, string $contentType = self::contentTypes['walletTransactionCreated'][0])
    {
        $request = $this->walletTransactionCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation walletTransactionCreatedAsync
     *
     * A new wallet transaction has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionCreatedRequest|null $wallet_transaction_created_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletTransactionCreatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request = null, string $contentType = self::contentTypes['walletTransactionCreated'][0])
    {
        return $this->walletTransactionCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation walletTransactionCreatedAsyncWithHttpInfo
     *
     * A new wallet transaction has been created
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionCreatedRequest|null $wallet_transaction_created_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletTransactionCreatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request = null, string $contentType = self::contentTypes['walletTransactionCreated'][0])
    {
        $returnType = '';
        $request = $this->walletTransactionCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'walletTransactionCreated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionCreatedRequest|null $wallet_transaction_created_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionCreated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function walletTransactionCreatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_created_request = null, string $contentType = self::contentTypes['walletTransactionCreated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling walletTransactionCreated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling walletTransactionCreated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling walletTransactionCreated'
            );
        }



        $resourcePath = '/wallet_transaction_created';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wallet_transaction_created_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wallet_transaction_created_request));
            } else {
                $httpBody = $wallet_transaction_created_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation walletTransactionPaymentFailure
     *
     * A payment attempt for a wallet transaction has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionPaymentFailureRequest|null $wallet_transaction_payment_failure_request Details of the wallet transaction and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionPaymentFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function walletTransactionPaymentFailure($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request = null, string $contentType = self::contentTypes['walletTransactionPaymentFailure'][0])
    {
        $this->walletTransactionPaymentFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request, $contentType);
    }

    /**
     * Operation walletTransactionPaymentFailureWithHttpInfo
     *
     * A payment attempt for a wallet transaction has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionPaymentFailureRequest|null $wallet_transaction_payment_failure_request Details of the wallet transaction and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionPaymentFailure'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function walletTransactionPaymentFailureWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request = null, string $contentType = self::contentTypes['walletTransactionPaymentFailure'][0])
    {
        $request = $this->walletTransactionPaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation walletTransactionPaymentFailureAsync
     *
     * A payment attempt for a wallet transaction has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionPaymentFailureRequest|null $wallet_transaction_payment_failure_request Details of the wallet transaction and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionPaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletTransactionPaymentFailureAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request = null, string $contentType = self::contentTypes['walletTransactionPaymentFailure'][0])
    {
        return $this->walletTransactionPaymentFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation walletTransactionPaymentFailureAsyncWithHttpInfo
     *
     * A payment attempt for a wallet transaction has failed on a payment provider
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionPaymentFailureRequest|null $wallet_transaction_payment_failure_request Details of the wallet transaction and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionPaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletTransactionPaymentFailureAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request = null, string $contentType = self::contentTypes['walletTransactionPaymentFailure'][0])
    {
        $returnType = '';
        $request = $this->walletTransactionPaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'walletTransactionPaymentFailure'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionPaymentFailureRequest|null $wallet_transaction_payment_failure_request Details of the wallet transaction and of the provider error (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionPaymentFailure'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function walletTransactionPaymentFailureRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_payment_failure_request = null, string $contentType = self::contentTypes['walletTransactionPaymentFailure'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling walletTransactionPaymentFailure'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling walletTransactionPaymentFailure'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling walletTransactionPaymentFailure'
            );
        }



        $resourcePath = '/wallet_transaction_payment_failure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wallet_transaction_payment_failure_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wallet_transaction_payment_failure_request));
            } else {
                $httpBody = $wallet_transaction_payment_failure_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation walletTransactionUpdated
     *
     * A wallet transaction has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionUpdatedRequest|null $wallet_transaction_updated_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function walletTransactionUpdated($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request = null, string $contentType = self::contentTypes['walletTransactionUpdated'][0])
    {
        $this->walletTransactionUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request, $contentType);
    }

    /**
     * Operation walletTransactionUpdatedWithHttpInfo
     *
     * A wallet transaction has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionUpdatedRequest|null $wallet_transaction_updated_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionUpdated'] to see the possible values for this operation
     *
     * @throws \Lago\LagoPhpClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function walletTransactionUpdatedWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request = null, string $contentType = self::contentTypes['walletTransactionUpdated'][0])
    {
        $request = $this->walletTransactionUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation walletTransactionUpdatedAsync
     *
     * A wallet transaction has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionUpdatedRequest|null $wallet_transaction_updated_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletTransactionUpdatedAsync($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request = null, string $contentType = self::contentTypes['walletTransactionUpdated'][0])
    {
        return $this->walletTransactionUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation walletTransactionUpdatedAsyncWithHttpInfo
     *
     * A wallet transaction has been updated
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionUpdatedRequest|null $wallet_transaction_updated_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function walletTransactionUpdatedAsyncWithHttpInfo($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request = null, string $contentType = self::contentTypes['walletTransactionUpdated'][0])
    {
        $returnType = '';
        $request = $this->walletTransactionUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'walletTransactionUpdated'
     *
     * @param  string $x_lago_signature Signature of the webhook payload (required)
     * @param  string $x_lago_signature_algorithm Algorithm used to generate the signature (required)
     * @param  string $x_lago_unique_key Unique id of the webhook. It can be used for idempotency (required)
     * @param  \Lago\LagoPhpClient\Model\WalletTransactionUpdatedRequest|null $wallet_transaction_updated_request Details of the wallet transaction (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['walletTransactionUpdated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function walletTransactionUpdatedRequest($x_lago_signature, $x_lago_signature_algorithm, $x_lago_unique_key, $wallet_transaction_updated_request = null, string $contentType = self::contentTypes['walletTransactionUpdated'][0])
    {

        // verify the required parameter 'x_lago_signature' is set
        if ($x_lago_signature === null || (is_array($x_lago_signature) && count($x_lago_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature when calling walletTransactionUpdated'
            );
        }

        // verify the required parameter 'x_lago_signature_algorithm' is set
        if ($x_lago_signature_algorithm === null || (is_array($x_lago_signature_algorithm) && count($x_lago_signature_algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_signature_algorithm when calling walletTransactionUpdated'
            );
        }

        // verify the required parameter 'x_lago_unique_key' is set
        if ($x_lago_unique_key === null || (is_array($x_lago_unique_key) && count($x_lago_unique_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_lago_unique_key when calling walletTransactionUpdated'
            );
        }



        $resourcePath = '/wallet_transaction_updated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_lago_signature !== null) {
            $headerParams['X-Lago-Signature'] = ObjectSerializer::toHeaderValue($x_lago_signature);
        }
        // header params
        if ($x_lago_signature_algorithm !== null) {
            $headerParams['X-Lago-Signature-Algorithm'] = ObjectSerializer::toHeaderValue($x_lago_signature_algorithm);
        }
        // header params
        if ($x_lago_unique_key !== null) {
            $headerParams['X-Lago-Unique-Key'] = ObjectSerializer::toHeaderValue($x_lago_unique_key);
        }



        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wallet_transaction_updated_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wallet_transaction_updated_request));
            } else {
                $httpBody = $wallet_transaction_updated_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
